STEP 1: Create Namespace for Vault

kubectl create namespace vault

Reason?
To separate Vault’s workloads from the rest of your cluster for organization and RBAC control.

STEP 2: Add Helm Repo and Install Vault with Raft HA

helm repo add hashicorp https://helm.releases.hashicorp.com
helm repo update


# helm upgrade --install vault hashicorp/vault -n vault -f vault-values.yaml

# kubectl get all -n vault

STEP 3: Expose Vault Using LoadBalancer
Create a service vault-service.yaml:



#Unseal the pods vaults for perfect runing state 
STEP 4: Initialize Vault (Run Once)
kubectl exec -n vault -it vault-0 -- vault operator init
 Copy and save:
	•	5 unseal keys
	•	1 initial root token



STEP 5: Unseal Vault on All Pods
Use any 3 keys on each Vault pod:

kubectl exec -n vault -it vault-0 -- vault operator unseal <key>
kubectl exec -n vault -it vault-1 -- vault operator unseal <key>
kubectl exec -n vault -it vault-2 -- vault operator unseal <key>

STEP 6: Login to Vault  
kubectl exec -n vault -it vault-0 -- vault login <root-token>

STEP 6a: Login to Vault  UI
#kubectl get vault-service -n vault   &. copy the loadbalancer url 

    1. Enable Kubernetes Auth on Vault
    kubectl exec -n vault -it vault-0 -- vault auth enable kubernetes
  

    2. Create the Vault Policy
    Create a policy file locally:
    cat <<EOF > noteapp-policy.hcl
    path "secret/data/noteapp" {
    capabilities = ["read"]
    }

    path "secret/metadata/noteapp" {
    capabilities = ["list"]
    }
    EOF
    Then upload and apply it:
    kubectl cp noteapp-policy.hcl vault/vault-0:/tmp/noteapp-policy.hcl
    kubectl exec -n vault -it vault-0 -- vault policy write noteapp /tmp/noteapp-policy.hcl


    3. Create a Service Account in Your App Namespace
    kubectl create namespace webapps
    kubectl create serviceaccount noteapp-sa -n webapps

    4. Create a Vault Role for the Service Account
    kubectl exec -n vault -it vault-0 -- vault write auth/kubernetes/role/noteapp \
    bound_service_account_names=noteapp-sa \
    bound_service_account_namespaces=webapps \
    policies=noteapp \
    ttl=24h


    5. Configure Kubernetes Auth Backend
    Extract values from cluster:
    SERVICE_ACCOUNT_NAME=noteapp-sa
    NAMESPACE=webapps
    SECRET_NAME=$(kubectl get sa $SERVICE_ACCOUNT_NAME -n $NAMESPACE -o jsonpath="{.secrets[0].name}")
    TOKEN_REVIEW_JWT=$(kubectl get secret $SECRET_NAME -n $NAMESPACE -o jsonpath="{.data.token}" | base64 --decode)
    KUBE_CA_CERT=$(kubectl get secret $SECRET_NAME -n $NAMESPACE -o jsonpath="{.data['ca.crt']}" | base64 --decode)
    KUBE_HOST=$(kubectl config view --raw -o=jsonpath='{.clusters[0].cluster.server}')


       #Now apply config:
        kubectl exec -n vault -it vault-0 -- vault write auth/kubernetes/config \
        token_reviewer_jwt="$TOKEN_REVIEW_JWT" \
        kubernetes_host="$KUBE_HOST" \
        kubernetes_ca_cert="$KUBE_CA_CERT"


        # Enable KV V2 Engine (Reason v2 Secret engine is because proper versioning & updating)
            kubectl exec -n vault -it vault-0 -- vault secrets enable -path=secret -version=2 kv


    6. Store the MongoDB Connection String in Vault
    Make sure you match casing with your app (your file reads from /vault/secrets/mongodb__connectionstring):
    kubectl exec -n vault -it vault-0 -- vault kv put secret/noteapp mongodb__connectionstring="mongodb://mongo-0.mongo,mongo-1.mongo,mongo-2.mongo:27017/NoteDb?replicaSet=rs0"    
